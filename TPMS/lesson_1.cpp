// лекция 2 взаимное исключение 

// mutex - поток захватывает мьютекс/ берет блокировку и входить в ритическую систему. В конце отпускает мьютекс 
// mutex - MUTual EXclussion

mutex lock() 
// critical section start here
...
lock_node->next = head_;
head_=lock_node;
...
mutex.inlock();


// race condition - нарушение инфариантво структуры данных 
/*

Состояние гонки (race condition) – 
это ошибка в многопоточной программе, 
когда результат её выполнения зависит от непредсказуемой последовательности выполнения потоков (или процессов), 
которые одновременно обращаются к общим данным. Потоки как бы "соревнуются" за доступ к ресурсу, 
и итоговое состояние данных определяется тем, 
какой поток первым завершит операцию, 
что может привести к некорректной работе программы или уязвимостям. 

*/

// data race - два потока без синхрони зации обращаются к одной ечейке памяти 
/*
Гонка данных (data race) – это состояние в многопоточной программе, 
когда два или более потоков одновременно обращаются к одной и той же области памяти (переменной или объекту), 
и при этом хотя бы один из потоков выполняет операцию записи, 
без какой-либо синхронизации доступа. 
Это приводит к непредсказуемому поведению программы, поскольку конечный результат зависит от того, 
в каком порядке выполняются операции чтения и записи потоками. 
*/

// свойства mutex(гарантии)

/*
взаимное исключение:
между парными вызоваими mutex.lock() и mutex.unlock() может находиться только один поток

свободв от взаимной блокировки:
если один иоии несколько потоков патыются захватить своболный мьютекс, то один из его вызовов mutex.lock() должен завершиться

второе свойство называют ГАРАНТИЕЙ ПРОГРЕССА
*/


// DEADLOCK 
// тяжелая форма взаисной блокировки - дэдлок 
// терминальное состояние: потоки не выйдут из него, чтобы не делал планировщик 
 

// LIVEBLOCK 
// легкая форма взаимной блокировки - лайблок 
// потоки мещают прогрессу друг друга, но при удачном планировании разойдутся


// глобальный прогресс 
// свобода от взаимной блокировки - гарантия глобального прогресса, какой-то из потоков войдет в критическую секцию.

// в тоже время какой-то неудачный поток может привести в вызов mutex.lock() бесконечное время. 

// ГАРАНТИИ И ПЛАНИРОВКЩИК
// взаимное исклюбчение(safety) 
// выполнение взаимного исключения не должно зависеть от повдеения планировщика. При любом планировании потоков никакние два потока не должны одновременно отказаться в критической секции 

// прогресс(liveness) 
// чтобы гарантировать прогресс, мы должны немного ограничиитть планировщик - он должен действовать ЧЕСТНО 

// если у потока отсаются неволненвые инструкци, то eventually пданировщик поставит его на процессор. 


// МОДЕЛЬ ИСПОЛНЕНИЯ 
// АТОМИК 
// чтобы реалтность соотвествовала модели переключений, мы должны спеуиальном образом аннотировать (для компилятор аи процкссора ) те переменные, которые используються для синхронизации
std::atomic<int>
// реализация атомика и почему зачем он нужен и тонкие моменты очень дз физтехов 


 