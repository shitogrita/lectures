# Лекция 2 — Взаимное исключение

## Race Condition — состояние гонки  

**Состояние гонки (race condition)** — это ошибка в многопоточной программе, когда результат её выполнения зависит от непредсказуемой последовательности выполнения потоков (или процессов), которые одновременно обращаются к общим данным.  

Потоки «соревнуются» за доступ к ресурсу, и итоговое состояние данных определяется тем, какой поток первым завершит операцию. Это может привести к:  
- нарушению инвариантов структуры данных,  
- некорректной работе программы,  
- уязвимостям.  

---

## Data Race — гонка данных  

**Гонка данных (data race)** — это состояние в многопоточной программе, когда:  
- два или более потоков одновременно обращаются к одной и той же области памяти (переменной или объекту),  
- хотя бы один поток выполняет операцию записи,  
- отсутствует синхронизация доступа.  

Итог:  
- поведение программы становится непредсказуемым,  
- результат зависит от того, в каком порядке выполняются операции чтения и записи потоками.  

---

## Свойства мьютекса (гарантии)  

1. **Взаимное исключение**  
   Между парными вызовами `mutex.lock()` и `mutex.unlock()` может находиться только один поток.  

2. **Свобода от взаимной блокировки (гарантия прогресса)**  
   Если один или несколько потоков пытаются захватить свободный мьютекс, то хотя бы один вызов `mutex.lock()` обязан завершиться.

3. От противного: пусть два потока одновременно оказалис тв критической секции.
   Посмотрим на тот поток, который при этом сделал запись в Victim_ **последним**. Пусть это поток под номером 1.
   Тогда в цикле while он должен увидеть 1) взведенный флаг want_ у потка с номером 0 2) victim_ == 1
---

## Deadlock  

**Deadlock (дэдлок)** — тяжёлая форма взаимной блокировки.  
- Это терминальное состояние.  
- Потоки не выйдут из него, что бы ни делал планировщик.  

---

## Livelock  

**Livelock (лайвлок)** — лёгкая форма взаимной блокировки.  
- Потоки мешают прогрессу друг друга.  
- При удачном планировании они могут «разойтись».  

---

## Глобальный прогресс  

- Свобода от взаимной блокировки = гарантия глобального прогресса.  
- Какой-то из потоков обязательно войдёт в критическую секцию.  

 Однако отдельный поток может бесконечно долго застрять в вызове `mutex.lock()`.  

---

## Гарантии и планировщик  

- **Взаимное исключение (safety):**  
  Должно выполняться при любом планировании потоков. Два потока не могут одновременно находиться в критической секции.  

- **Прогресс (liveness):**  
  Чтобы гарантировать прогресс, требуется ограничение на планировщик — он должен действовать честно.  

**Честность планировщика:**  
- если у потока есть невыполненные инструкции,  
- то **рано или поздно** планировщик предоставит ему процессор.  

---

## Модель исполнения  

### Атомики  

Чтобы реальность соответствовала модели переключений, нужно специальным образом аннотировать переменные, которые используются для синхронизации (для компилятора и процессора).  

Пример:  
```cpp
#include <atomic>
std::atomic<int> counter = 0;
```

# Атомики в C++

## Зачем нужны атомики?

- **Гарантируют атомарность операций**  
  Чтение, запись, инкремент и другие операции выполняются неделимо.

- **Обеспечивают правильный порядок выполнения**  
  Предотвращают «разрушительные» оптимизации компилятора и процессора.

- **Основa для примитивов синхронизации**  
  На базе атомиков реализованы `mutex`, `spinlock`, `CAS` и другие низкоуровневые механизмы.

---

## Тонкие моменты

- **Режимы памяти (`memory_order`)**  
  - `relaxed` — минимальные гарантии, максимальная скорость.  
  - `acquire/release` — синхронизация между потоками с оптимальным балансом.  
  - `seq_cst` — строгая последовательная консистентность, самая надёжная, но медленная.  

- **Сложность выбора memory order**  
  Ошибки приводят к редким и трудноуловимым багам, которые сложно воспроизвести.

- **Под капотом STL-примитивов**  
  Высокоуровневые механизмы (`std::mutex`, `std::condition_variable`) внутри опираются на атомики.

---


## Шпаргалка: Race condition vs Data race vs Deadlock vs Livelock

| Явление         | Определение                                                                 | Причина                                  | Последствия                                           |
|-----------------|----------------------------------------------------------------------------|------------------------------------------|------------------------------------------------------|
| **Race condition** | Логическая ошибка: результат зависит от порядка выполнения потоков.        | Несогласованное использование общих данных. | Нарушение инвариантов, некорректное поведение.        |
| **Data race**      | Два+ потока обращаются к одной памяти без синхронизации, один пишет.       | Отсутствие защиты (мьютексы, атомики).     | Непредсказуемое состояние памяти, баги.              |
| **Deadlock**       | Потоки навсегда блокируют друг друга, ожидая ресурсы.                     | Неправильный порядок захвата блокировок.  | Программа «замерзает» и не продолжает работу.         |
| **Livelock**       | Потоки мешают друг другу, но не продвигаются к цели.                      | Чрезмерные попытки избежать deadlock.     | Программа работает, но без прогресса (вечное ожидание). |

---


# Пример собственной реализации атомика

В реальных системах атомики реализуются с помощью специальных
машинных инструкций (`lock cmpxchg`, `xchg`, `fetch_add` и др.).
Мы можем обернуть их в C++ класс.

## Реализация `AtomicInt` на базе CAS (Compare-And-Swap)

```cpp
#include <atomic>
#include <thread>
#include <iostream>

class AtomicInt {
private:
    std::atomic<int> value; // используем встроенный атомик

public:
    AtomicInt(int v = 0) : value(v) {}

    // атомарное чтение
    int load(std::memory_order order = std::memory_order_seq_cst) const {
        return value.load(order);
    }

    // атомарная запись
    void store(int v, std::memory_order order = std::memory_order_seq_cst) {
        value.store(v, order);
    }

    // атомарный инкремент
    int fetch_add(int arg, std::memory_order order = std::memory_order_seq_cst) {
        return value.fetch_add(arg, order);
    }

    // атомарное уменьшение
    int fetch_sub(int arg, std::memory_order order = std::memory_order_seq_cst) {
        return value.fetch_sub(arg, order);
    }

    // compare-and-swap (CAS)
    bool compare_and_swap(int& expected, int desired,
                          std::memory_order order = std::memory_order_seq_cst) {
        return value.compare_exchange_strong(expected, desired, order);
    }
};
```

